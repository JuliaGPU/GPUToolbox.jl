var documenterSearchIndex = {"docs":
[{"location":"#GPUToolbox.jl","page":"Home","title":"GPUToolbox.jl","text":"","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#GPUToolbox.LazyInitialized","page":"Home","title":"GPUToolbox.LazyInitialized","text":"LazyInitialized{T}()\n\nA thread-safe, lazily-initialized wrapper for a value of type T. Initialize and fetch the value by calling get!. The constructor is ensured to only be called once.\n\nThis type is intended for lazy initialization of e.g. global structures, without using __init__. It is similar to protecting accesses using a lock, but is much cheaper.\n\n\n\n\n\n","category":"type"},{"location":"#GPUToolbox.Literal","page":"Home","title":"GPUToolbox.Literal","text":"Literal{T}\n\nConstruct an object that can be used to convert literals to other types. One can use the object in suffix form 1*i8 or 1i8 to perform the conversion.\n\nExported constants\n\ni8: Convert to Int8\ni16: Convert to Int16\ni32: Convert to Int32\nu8: Convert to UInt8\nu16: Convert to UInt16\nu32: Convert to UInt32\n\n\n\n\n\n","category":"type"},{"location":"#GPUToolbox.SimpleVersion","page":"Home","title":"GPUToolbox.SimpleVersion","text":"SimpleVersion(major, [minor])\nSimpleVersion(v::AbstractString)\n\nA GPU-compatible version number.\n\n\n\n\n\n","category":"type"},{"location":"#GPUToolbox.@checked-Tuple{Any}","page":"Home","title":"GPUToolbox.@checked","text":"@checked function foo(...)\n    rv = ...\n    return rv\nend\n\nMacro for wrapping a function definition returning a status code. Two versions of the function will be generated: foo, with the function execution wrapped by an invocation of the check function (to be implemented by the caller of this macro), and unchecked_foo where no such invocation is present and the status code is returned to the caller.\n\n\n\n\n\n","category":"macro"},{"location":"#GPUToolbox.@debug_ccall-Tuple{Any}","page":"Home","title":"GPUToolbox.@debug_ccall","text":"@debug_ccall ...\n\nA version of ccall` that prints the ccall, its arguments, and its return value.\n\n\n\n\n\n","category":"macro"},{"location":"#GPUToolbox.@gcsafe_ccall","page":"Home","title":"GPUToolbox.@gcsafe_ccall","text":"@gcsafe_ccall ...\n\nCall a foreign function just like @ccall, but marking it safe for the GC to run. This is useful for functions that may block, so that the GC isn't blocked from running, but may also be required to prevent deadlocks (see JuliaGPU/CUDA.jl#2261).\n\nNote that this is generally only safe with non-Julia C functions that do not call back into the Julia directly.\n\n\n\n\n\n","category":"macro"},{"location":"#GPUToolbox.@memoize-Tuple","page":"Home","title":"GPUToolbox.@memoize","text":"@memoize [key::T] [maxlen=...] begin\n    # expensive computation\nend::T\n\nLow-level, no-frills memoization macro that stores values in a thread-local, typed cache. The types of the caches are derived from the syntactical type assertions.\n\nThe cache consists of two levels, the outer one indexed with the thread index. If no key is specified, the second level of the cache is dropped.\n\nIf the the maxlen option is specified, the key is assumed to be an  integer, and the secondary cache will be a vector with length maxlen. Otherwise, a dictionary is used.\n\n\n\n\n\n","category":"macro"},{"location":"#GPUToolbox.@sv_str-Tuple{Any}","page":"Home","title":"GPUToolbox.@sv_str","text":"sv\"str\"\n\nConstruct a SimpleVersion from str.\n\n\n\n\n\n","category":"macro"}]
}
